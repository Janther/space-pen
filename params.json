{"name":"space-pen","tagline":"A simple and powerful client-side view framework that works in zero-gravity.","body":"# SpacePen [![Build Status](https://travis-ci.org/atom/space-pen.png?branch=master)](https://travis-ci.org/atom/space-pen)\r\n\r\n## Write markup on the final frontier\r\n\r\nSpacePen is a powerful but minimalist client-side view framework for\r\nCoffeeScript. It combines the \"view\" and \"controller\" into a single jQuery\r\nobject, whose markup is expressed with an embedded DSL similar to Markaby for\r\nRuby.\r\n\r\n## Basics\r\n\r\nView objects extend from the View class and have a @content class method where\r\nyou express their HTML contents with an embedded markup DSL:\r\n\r\n```coffeescript\r\nclass Spacecraft extends View\r\n  @content: ->\r\n    @div =>\r\n      @h1 \"Spacecraft\"\r\n      @ol =>\r\n        @li \"Apollo\"\r\n        @li \"Soyuz\"\r\n        @li \"Space Shuttle\"\r\n```\r\n\r\nViews descend from jQuery's prototype, so when you construct one you can call\r\njQuery methods on it just as you would a DOM fragment created with `$(...)`.\r\n\r\n```coffeescript\r\nview = new Spacecraft\r\nview.find('ol').append('<li>Star Destroyer</li>')\r\n\r\nview.on 'click', 'li', ->\r\n  alert \"They clicked on #{$(this).text()}\"\r\n```\r\n\r\nBut SpacePen views are more powerful than normal jQuery fragments because they\r\nlet you define custom methods:\r\n\r\n```coffeescript\r\nclass Spacecraft extends View\r\n  @content: -> ...\r\n\r\n  addSpacecraft: (name) ->\r\n    @find('ol').append \"<li>#{name}</li>\"\r\n\r\n\r\nview = new Spacecraft\r\nview.addSpacecraft \"Enterprise\"\r\n```\r\n\r\nYou can also pass arguments on construction, which get passed to both the\r\n`@content` method and the view's constructor.\r\n\r\n```coffeescript\r\nclass Spacecraft extends View\r\n  @content: (params) ->\r\n    @div =>\r\n      @h1 params.title\r\n      @ol =>\r\n        @li name for name in params.spacecraft\r\n\r\nview = new Spacecraft(title: \"Space Weapons\", spacecraft: [\"TIE Fighter\", \"Death Star\", \"Warbird\"])\r\n```\r\n\r\nMethods from the jQuery prototype can be gracefully overridden using `super`:\r\n\r\n```coffeescript\r\nclass Spacecraft extends View\r\n  @content: -> ...\r\n\r\n  hide: ->\r\n    console.log \"Hiding Spacecraft List\"\r\n    super()\r\n```\r\n\r\nIf you override the View class's constructor, ensure you call `super`.\r\nAlternatively, you can define an `initialize` method, which the constructor will\r\ncall for you automatically with the constructor's arguments.\r\n\r\n```coffeescript\r\nclass Spacecraft extends View\r\n  @content: -> ...\r\n\r\n  initialize: (params) ->\r\n    @title = params.title\r\n```\r\n\r\n## Outlets and Events\r\n\r\nSpacePen will automatically create named reference for any element with an\r\n`outlet` attribute. For example, if the `ol` element has an attribute\r\n`outlet=list`, the view object will have a `list` entry pointing to a jQuery\r\nwrapper for the `ol` element.\r\n\r\n```coffeescript\r\nclass Spacecraft extends View\r\n  @content: ->\r\n    @div =>\r\n      @h1 \"Spacecraft\"\r\n      @ol outlet: \"list\", =>\r\n        @li \"Apollo\"\r\n        @li \"Soyuz\"\r\n        @li \"Space Shuttle\"\r\n\r\n  addSpacecraft: (name) ->\r\n    @list.append(\"<li>#{name}</li>\")\r\n```\r\n\r\nElements can also have event name attributes whose value references a custom\r\nmethod. For example, if a `button` element has an attribute\r\n`click=launchSpacecraft`, then SpacePen will invoke the `launchSpacecraft`\r\nmethod on the button`s parent view when it is clicked:\r\n\r\n```coffeescript\r\nclass Spacecraft extends View\r\n  @content: ->\r\n    @div =>\r\n      @h1 \"Spacecraft\"\r\n      @ol =>\r\n        @li click: 'launchSpacecraft', \"Saturn V\"\r\n\r\n  launchSpacecraft: (event, element) ->\r\n    console.log \"Preparing #{element.name} for launch!\"\r\n```\r\n## Markup DSL Details\r\n\r\n### Tag Methods (`@div`, `@h1`, etc.)\r\n\r\nAs you've seen so far, the markup DSL is pretty straightforward. From the\r\n`@content` class method or any method it calls, just invoke instance methods\r\nnamed for the HTML tags you want to generate. There are 3 types of arguments you\r\ncan pass to a tag method:\r\n\r\n* Strings\r\n  The string will be HTML-escaped and used as the text contents of the generated tag.\r\n\r\n* Hashes\r\n  The key-value pairs will be used as the attributes of the generated tag.\r\n\r\n* Functions (bound with `=>`)\r\n  The function will be invoked in-between the open and closing tag to produce\r\n  the HTML element's contents.\r\n\r\nIf you need to emit a non-standard tag, you can use the `@tag(name, args...)`\r\nmethod to name the tag with a string:\r\n\r\n```coffeescript\r\n@tag 'bubble', type: \"speech\", => ...\r\n```\r\n\r\n### Text Methods\r\n\r\n* `@text(string)`\r\n  Emits the HTML-escaped string as text wherever it is called.\r\n\r\n* `@raw(string)`\r\n  Passes the given string through unescaped. Use this when you need to emit markup directly that was generated beforehand.\r\n\r\n## Subviews\r\n\r\nSubviews are a great way to make your view code more modular. The\r\n`@subview(name, view)` method takes a name and another view object. The view\r\nobject will be inserted at the location of the call, and a reference with the\r\ngiven name will be wired to it from the parent view. A `parentView` reference\r\nwill be created on the subview pointing at the parent.\r\n\r\n```coffeescript\r\nclass Spacecraft extends View\r\n  @content: (params) ->\r\n    @div =>\r\n      @subview 'launchController', new LaunchController(countdown: params.countdown)\r\n      @h1 \"Spacecraft\"\r\n      ...\r\n```\r\n\r\n## Freeform Markup Generation\r\n\r\nYou don't need a View class to use the SpacePen markup DSL. Call `View.render`\r\nwith an unbound function (`->`, not `=>`) that calls tag methods, and it will\r\nreturn a document fragment for ad-hoc use. This method is also assigned to the\r\n`$$` global variable for convenience.\r\n\r\n```coffeescript\r\nview.list.append $$ ->\r\n  @li =>\r\n    @text \"Starship\"\r\n    @em \"Enterprise\"\r\n```\r\n\r\n## jQuery extensions\r\n\r\n### $.fn.view\r\nYou can retrieve the view object for any DOM element by calling `view()` on it.\r\nThis usually shouldn't be necessary, as most DOM manipulation will take place\r\nwithin the view itself using outlet references, but is occasionally helpful.\r\n\r\n```coffeescript\r\nview = new Spacecraft\r\n$('body').append(view)\r\n\r\n# assuming no other li elements on the DOM, for example purposes,\r\n# the following expression should be true\r\n$('li').view() == view\r\n```\r\n\r\n### After Attach Hooks\r\nThe `initialize` method is always called when the view is still a detached DOM\r\nfragment, before it is appended to the DOM. This is usually okay, but\r\noccasionally you'll have some initialization logic that depends on the view\r\nactually being on the DOM. For example, you may depend on applying a CSS rule\r\nbefore measuring an element's height.\r\n\r\nSpacePen extends jQuery manipulation methods like `append`, `replaceWith`, etc.\r\nto call `afterAttach` hooks on your view objects when they are appended to other\r\nelements. The hook will be called with a boolean value indicating whether the\r\nview is attached to the main DOM or just to another DOM fragment. If\r\n`afterAttach` is called with `true`, you can assume your object is attached to\r\nthe page.\r\n\r\n```coffeescript\r\nclass Spacecraft extends View\r\n  @content: -> ...\r\n\r\n  afterAttach: (onDom) ->\r\n    if onDom\r\n      console.log \"With CSS applied, my height is\", @height()\r\n    else\r\n      console.log \"I just attached to\", @parent()\r\n```\r\n\r\n### Before Remove Hooks\r\nSpacePen calls the `beforeRemove` hook whenever a view is removed from the DOM\r\nvia a jQuery method. This works if the view is removed directly with `remove` or\r\nindirectly when a method like `empty` or `html` is called on a parent element.\r\nThis is a good place to clean up subscriptions and other view-specific state.\r\n\r\n```coffeescript\r\nclass Spacecraft extends View\r\n  @content: -> ...\r\n\r\n  initialize: ->\r\n    $(window).on 'resize.spacecraft', -> ...\r\n\r\n  beforeRemove: ->\r\n    $(window).off('.spacecraft')\r\n```\r\n\r\n## Anticipated Concerns / Objections\r\n\r\n### What about the view/controller distinction?\r\nMVC was invented in a setting where graphics rendering was substantially more\r\ncomplex than it is in a web browser. In Cocoa development, for example, a view\r\nobject's primary role is to implement `drawRect` and forward UI events to the\r\ncontroller. But in a browser, you don't need to handle your own rendering with\r\n`drawRect`. Instead, you express the view declaratively using markup and CSS,\r\nand the browser takes care of the rest. The closest thing to a MVC \"view\" in\r\nthis world is a fragment of markup, but this contains very little logic. On the\r\nweb, the view/controller distinction is like a vestigial organ: It's a solution\r\nto a problem we no longer have, and no longer justifies the conceptual overhead\r\nof using two objects where one would do.\r\n\r\n### Our designers can't handle writing markup in CoffeeScript\r\nOkay. SpacePen might not be the right fit for you. But are you sure they can't\r\nhandle it? What if you pair with them for a couple hours and teach them what to\r\ndo? There's also the potential of plugging in another template language for\r\ncontent generation, while keeping the rest of the framework. But if developers\r\nare writing the majority of the markup, expressing it directly in CoffeeScript\r\nis a productivity win.\r\n\r\n\r\n## Hacking on SpacePen\r\n\r\nTo run specs, start a web server in the root of the repository:\r\n\r\n```sh\r\ncd ~/code/space-pen\r\nnpm install\r\nnpm start\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}